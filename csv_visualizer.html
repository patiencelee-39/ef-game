<!DOCTYPE html>
<html lang="zh-TW">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>åŸ·è¡ŒåŠŸèƒ½è¨“ç·´éŠæˆ² - è³‡æ–™åˆ†æå ±å‘Šç”Ÿæˆå™¨</title>

    <!-- â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•— -->
    <!-- â•‘  å¼•å…¥ Chart.js åœ–è¡¨åº«                                                 â•‘ -->
    <!-- â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <script src="https://cdn.jsdelivr.net/npm/chart.js@4.4.1/dist/chart.umd.min.js"></script>

    <!-- â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•— -->
    <!-- â•‘  å¼•å…¥ PapaParse - CSV è§£æåº«                                          â•‘ -->
    <!-- â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <script src="https://cdn.jsdelivr.net/npm/papaparse@5.4.1/papaparse.min.js"></script>

    <style>
      /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */
      /* CSS æ¨£å¼è¨­å®š                                                            */
      /* â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• */

      :root {
        --primary-color: #667eea;
        --success-color: #4caf50;
        --error-color: #f44336;
        --warning-color: #ff9800;
      }

      * {
        margin: 0;
        padding: 0;
        box-sizing: border-box;
      }

      body {
        font-family: -apple-system, BlinkMacSystemFont, "Segoe UI",
          "Microsoft JhengHei", sans-serif;
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        min-height: 100vh;
        padding: 20px;
        color: white;
      }

      .container {
        max-width: 1400px;
        margin: 0 auto;
      }

      .header {
        text-align: center;
        margin-bottom: 40px;
        padding: 30px;
        background: rgba(255, 255, 255, 0.1);
        border-radius: 20px;
        backdrop-filter: blur(10px);
      }

      .header h1 {
        font-size: 2.5em;
        margin-bottom: 10px;
      }

      .header p {
        font-size: 1.1em;
        opacity: 0.9;
      }

      /* ä¸Šå‚³å€åŸŸæ¨£å¼ */
      .upload-section {
        background: white;
        color: #333;
        padding: 40px;
        border-radius: 20px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        margin-bottom: 30px;
      }

      .upload-area {
        border: 3px dashed var(--primary-color);
        border-radius: 15px;
        padding: 60px 20px;
        text-align: center;
        transition: all 0.3s;
        cursor: pointer;
      }

      .upload-area:hover {
        border-color: var(--success-color);
        background: rgba(102, 126, 234, 0.05);
      }

      .upload-area.dragover {
        border-color: var(--success-color);
        background: rgba(76, 175, 80, 0.1);
      }

      .upload-icon {
        font-size: 4em;
        margin-bottom: 20px;
      }

      input[type="file"] {
        display: none;
      }

      .btn {
        background: var(--primary-color);
        color: white;
        border: none;
        padding: 15px 40px;
        font-size: 1.1em;
        border-radius: 50px;
        cursor: pointer;
        transition: all 0.3s;
        font-weight: bold;
      }

      .btn:hover {
        transform: translateY(-2px);
        box-shadow: 0 5px 20px rgba(102, 126, 234, 0.4);
      }

      .btn:active {
        transform: translateY(0);
      }

      .btn-secondary {
        background: #7f8c8d;
      }

      /* è³‡æ–™é è¦½å€ */
      .preview-section {
        display: none;
        background: white;
        color: #333;
        padding: 30px;
        border-radius: 20px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        margin-bottom: 30px;
      }

      .participant-info {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 20px;
        border-radius: 15px;
        margin-bottom: 20px;
        font-size: 1.2em;
        text-align: center;
      }

      .data-info {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
        gap: 20px;
        margin: 20px 0;
      }

      .info-item {
        text-align: center;
        padding: 20px;
        background: #f8f9fa;
        border-radius: 10px;
      }

      .info-value {
        font-size: 2em;
        font-weight: bold;
        color: var(--primary-color);
      }

      .info-label {
        color: #666;
        margin-top: 5px;
        font-size: 0.9em;
      }

      /* åœ–è¡¨å€åŸŸ */
      .charts-section {
        display: none;
      }

      .chart-container {
        background: white;
        padding: 30px;
        border-radius: 20px;
        box-shadow: 0 10px 40px rgba(0, 0, 0, 0.3);
        margin-bottom: 30px;
      }

      .chart-title {
        color: #333;
        margin-bottom: 20px;
        padding-bottom: 15px;
        border-bottom: 3px solid var(--primary-color);
      }

      canvas {
        max-height: 400px;
      }

      /* çµ±è¨ˆæ‘˜è¦ */
      .stats-grid {
        display: grid;
        grid-template-columns: repeat(auto-fit, minmax(250px, 1fr));
        gap: 20px;
        margin-bottom: 30px;
      }

      .stat-card {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 25px;
        border-radius: 15px;
        box-shadow: 0 5px 20px rgba(0, 0, 0, 0.2);
      }

      .stat-card h3 {
        font-size: 0.9em;
        opacity: 0.9;
        margin-bottom: 10px;
      }

      .stat-card .value {
        font-size: 2.5em;
        font-weight: bold;
      }

      /* å›åˆåˆ†éš”æ¨™é¡Œ */
      .round-header {
        background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
        color: white;
        padding: 20px;
        border-radius: 15px;
        margin: 30px 0 20px 0;
        text-align: center;
        font-size: 1.5em;
        font-weight: bold;
      }

      /* è¼‰å…¥å‹•ç•« */
      .loading {
        text-align: center;
        padding: 40px;
        display: none;
      }

      .spinner {
        border: 4px solid rgba(255, 255, 255, 0.3);
        border-top: 4px solid white;
        border-radius: 50%;
        width: 50px;
        height: 50px;
        animation: spin 1s linear infinite;
        margin: 0 auto;
      }

      @keyframes spin {
        0% {
          transform: rotate(0deg);
        }
        100% {
          transform: rotate(360deg);
        }
      }

      /* éŒ¯èª¤è¨Šæ¯ */
      .error-message {
        background: #f44336;
        color: white;
        padding: 20px;
        border-radius: 10px;
        margin: 20px 0;
        display: none;
      }

      /* èªªæ˜æ–‡å­— */
      .instructions {
        background: #e3f2fd;
        padding: 20px;
        border-radius: 10px;
        margin: 20px 0;
        color: #1565c0;
      }

      .instructions h3 {
        margin-bottom: 10px;
      }

      .instructions ol {
        margin-left: 20px;
      }

      .instructions li {
        margin: 8px 0;
      }

      /* å·¥ä½œè¨˜æ†¶æ¸¬è©¦å€ */
      .wm-section {
        background: #fff3e0;
        padding: 20px;
        border-radius: 10px;
        margin: 20px 0;
        border-left: 5px solid var(--warning-color);
      }

      .wm-section h4 {
        color: var(--warning-color);
        margin-bottom: 10px;
      }
    </style>
  </head>
  <body>
    <!-- â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•— -->
    <!-- â•‘  æ¨™é¡Œå€                                                               â•‘ -->
    <!-- â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
    <div class="container">
      <div class="header">
        <h1>ğŸ“Š åŸ·è¡ŒåŠŸèƒ½è¨“ç·´éŠæˆ²</h1>
        <p>è³‡æ–™åˆ†æå ±å‘Šç”Ÿæˆå™¨ v2.0</p>
      </div>

      <!-- â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•— -->
      <!-- â•‘  ä¸Šå‚³å€åŸŸ                                                             â•‘ -->
      <!-- â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
      <div class="upload-section">
        <div class="instructions">
          <h3>ğŸ“‹ ä½¿ç”¨èªªæ˜</h3>
          <ol>
            <li>æº–å‚™å¥½å¾éŠæˆ²åŒ¯å‡ºçš„ CSV æª”æ¡ˆ</li>
            <li>é»æ“Šä¸‹æ–¹å€åŸŸæˆ–æ‹–æ›³æª”æ¡ˆä¸Šå‚³</li>
            <li>ç³»çµ±æœƒè‡ªå‹•åˆ†æ 4 å€‹å›åˆ + 4 å€‹å·¥ä½œè¨˜æ†¶æ¸¬è©¦çš„è³‡æ–™</li>
            <li>æŸ¥çœ‹è©³ç´°çš„åœ–è¡¨åˆ†æå ±å‘Š</li>
          </ol>
        </div>

        <div class="upload-area" id="uploadArea">
          <div class="upload-icon">ğŸ“</div>
          <h2>é»æ“Šæˆ–æ‹–æ›³ CSV æª”æ¡ˆåˆ°é€™è£¡ (æ”¯æ´å¤šæª”æ¡ˆ)</h2>
          <p style="margin: 15px 0; color: #666">
            è«‹ä¸Šå‚³ "EFè¨“ç·´éŠæˆ²æ•¸æ“š_*.csv" æª”æ¡ˆ (æ”¯æ´å¤šä½åƒèˆ‡è€…æ¯”è¼ƒ)
          </p>
          <input type="file" id="csvFile" accept=".csv" multiple />
          <button
            class="btn"
            onclick="document.getElementById('csvFile').click()"
          >
            é¸æ“‡æª”æ¡ˆ
          </button>
        </div>

        <div class="error-message" id="errorMessage"></div>
        <div class="loading" id="loading">
          <div class="spinner"></div>
          <p style="margin-top: 20px">æ­£åœ¨åˆ†æè³‡æ–™...</p>
        </div>
      </div>

      <!-- â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•— -->
      <!-- â•‘  è³‡æ–™é è¦½å€                                                           â•‘ -->
      <!-- â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
      <div class="preview-section" id="previewSection">
        <div class="participant-info" id="participantInfo">
          åƒèˆ‡è€…ï¼š<span id="participantName">-</span>
        </div>

        <h2>ğŸ“ˆ è³‡æ–™æ¦‚è¦½</h2>
        <div class="data-info">
          <div class="info-item">
            <div class="info-value" id="totalTrials">0</div>
            <div class="info-label">ä¸€èˆ¬è©¦é¡Œç¸½æ•¸</div>
          </div>
          <div class="info-item">
            <div class="info-value" id="correctRate">0%</div>
            <div class="info-label">æ•´é«”æ­£ç¢ºç‡</div>
          </div>
          <div class="info-item">
            <div class="info-value" id="avgRT">0 ms</div>
            <div class="info-label">å¹³å‡åæ‡‰æ™‚é–“</div>
          </div>
          <div class="info-item">
            <div class="info-value" id="wmTests">0</div>
            <div class="info-label">å·¥ä½œè¨˜æ†¶æ¸¬è©¦æ•¸</div>
          </div>
        </div>

        <button
          class="btn"
          onclick="generateCharts()"
          style="margin-right: 10px"
        >
          ğŸ“Š ç”Ÿæˆå®Œæ•´åœ–è¡¨åˆ†æ
        </button>
        <button class="btn btn-secondary" onclick="resetApp()">
          ğŸ”„ é‡æ–°ä¸Šå‚³
        </button>
      </div>

      <!-- â•”â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•— -->
      <!-- â•‘  åœ–è¡¨é¡¯ç¤ºå€                                                           â•‘ -->
      <!-- â•šâ•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â• -->
      <div class="charts-section" id="chartsSection">
        <!-- çµ±è¨ˆæ‘˜è¦å¡ç‰‡ -->
        <div class="stats-grid" id="statsGrid"></div>

        <!-- å›åˆ 1 åˆ†æ -->
        <div class="round-header">ğŸ± å›åˆ 1ï¼šè²“å’ªèˆ‡èµ·å¸ï¼ˆåŸºç¤ Go/No-Goï¼‰</div>
        <div class="chart-container">
          <h2 class="chart-title">ğŸ“ˆ å›åˆ 1 - åæ‡‰æ™‚é–“è¶¨å‹¢</h2>
          <canvas id="round1RTChart"></canvas>
        </div>

        <!-- å›åˆ 2 åˆ†æ -->
        <div class="round-header">ğŸ‘¤ å›åˆ 2ï¼šèµ·å¸èˆ‡äººç‰©ï¼ˆæ¢ä»¶æ€§ Go/No-Goï¼‰</div>
        <div class="chart-container">
          <h2 class="chart-title">ğŸ“ˆ å›åˆ 2 - åæ‡‰æ™‚é–“è¶¨å‹¢</h2>
          <canvas id="round2RTChart"></canvas>
        </div>

        <!-- å›åˆ 3 åˆ†æ -->
        <div class="round-header">ğŸŸ å›åˆ 3ï¼šé­šèˆ‡é¯Šé­šï¼ˆé€²éš Go/No-Goï¼‰</div>
        <div class="chart-container">
          <h2 class="chart-title">ğŸ“ˆ å›åˆ 3 - åæ‡‰æ™‚é–“è¶¨å‹¢</h2>
          <canvas id="round3RTChart"></canvas>
        </div>

        <!-- å›åˆ 4 åˆ†æ -->
        <div class="round-header">ğŸŒ™ å›åˆ 4ï¼šç™½å¤©/æ™šä¸Šé¯Šé­šï¼ˆè¤‡é›œæ¢ä»¶ï¼‰</div>
        <div class="chart-container">
          <h2 class="chart-title">ğŸ“ˆ å›åˆ 4 - åæ‡‰æ™‚é–“è¶¨å‹¢</h2>
          <canvas id="round4RTChart"></canvas>
        </div>

        <!-- ç¶œåˆæ¯”è¼ƒ -->
        <div class="round-header">ğŸ“Š ç¶œåˆåˆ†æ</div>

        <div class="chart-container">
          <h2 class="chart-title">ğŸ¯ å„å›åˆæ­£ç¢ºç‡æ¯”è¼ƒ</h2>
          <canvas id="accuracyComparisonChart"></canvas>
        </div>

        <div class="chart-container">
          <h2 class="chart-title">â±ï¸ å„å›åˆå¹³å‡åæ‡‰æ™‚é–“</h2>
          <canvas id="rtComparisonChart"></canvas>
        </div>

        <!-- å·¥ä½œè¨˜æ†¶æ¸¬è©¦çµæœ -->
        <div class="round-header">ğŸ§  ç­”é¡Œç´€éŒ„å·¥ä½œè¨˜æ†¶æ¸¬è©¦ï¼šè©³ç´°</div>
        <div class="wm-section" id="wmResults"></div>

        <!-- å·¥ä½œè¨˜æ†¶æ¸¬è©¦åœ–è¡¨åˆ†æ -->
        <div class="chart-container">
          <h2 class="chart-title">ğŸ“Š å·¥ä½œè¨˜æ†¶æ¸¬è©¦ - æ­£ç¢ºç‡åˆ†æ</h2>
          <canvas id="wmAccuracyChart"></canvas>
          <div
            id="wmAccuracyLegend"
            style="
              display: flex;
              justify-content: center;
              gap: 20px;
              margin-top: 15px;
              flex-wrap: wrap;
            "
          ></div>
        </div>

        <div class="chart-container">
          <h2 class="chart-title">â±ï¸ å·¥ä½œè¨˜æ†¶æ¸¬è©¦ - åæ‡‰æ™‚é–“åˆ†æ</h2>
          <canvas id="wmRTChart"></canvas>
          <div
            id="wmRTLegend"
            style="
              display: flex;
              justify-content: center;
              gap: 20px;
              margin-top: 15px;
              flex-wrap: wrap;
            "
          ></div>
        </div>

        <!-- ä¸‹è¼‰æŒ‰éˆ• -->
        <div style="text-align: center; margin-top: 40px">
          <button class="btn btn-secondary" onclick="resetApp()">
            ğŸ”„ é‡æ–°ä¸Šå‚³
          </button>
        </div>
      </div>
    </div>

    <script>
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // JavaScript ä¸»ç¨‹å¼
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      // [æ•™å­¸] å…¨åŸŸè®Šæ•¸
      let parsedData = null;
      let regularTrials = []; // ä¸€èˆ¬è©¦é¡Œï¼ˆå›åˆ 1-4ï¼‰
      let wmTrials = []; // å·¥ä½œè¨˜æ†¶æ¸¬è©¦
      let charts = {};

      // [æ–°å¢] å®šç¾©çµ±ä¸€çš„å›åˆé¡è‰² (Round 1~4 / WM1~WM4)
      const ROUND_COLORS = {
        1: "rgba(255, 99, 132, 0.8)", // ç´…
        2: "rgba(54, 162, 235, 0.8)", // è—
        3: "rgba(255, 206, 86, 0.8)", // é»ƒ
        4: "rgba(75, 192, 192, 0.8)", // ç¶ 
      };

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // åˆå§‹åŒ–
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      document.addEventListener("DOMContentLoaded", function () {
        const csvFile = document.getElementById("csvFile");
        const uploadArea = document.getElementById("uploadArea");

        csvFile.addEventListener("change", handleFileSelect);

        uploadArea.addEventListener("dragover", (e) => {
          e.preventDefault();
          uploadArea.classList.add("dragover");
        });

        uploadArea.addEventListener("dragleave", () => {
          uploadArea.classList.remove("dragover");
        });

        uploadArea.addEventListener("drop", (e) => {
          e.preventDefault();
          uploadArea.classList.remove("dragover");

          const files = e.dataTransfer.files;
          if (files.length > 0) {
            csvFile.files = files;
            handleFileSelect({ target: csvFile });
          }
        });
      });

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // è™•ç†æª”æ¡ˆé¸æ“‡
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      function handleFileSelect(event) {
        const files = Array.from(event.target.files);

        if (files.length === 0) return;

        showLoading(true);
        hideError();

        let completedParses = 0;
        const parsedFiles = [];

        // 1. è§£ææ‰€æœ‰æª”æ¡ˆ
        files.forEach((file) => {
          Papa.parse(file, {
            header: true,
            skipEmptyLines: true,
            complete: function (results) {
              parsedFiles.push({
                uploadName: file.name,
                data: results.data,
              });
              completedParses++;

              // ç•¶æ‰€æœ‰æª”æ¡ˆéƒ½è§£æå®Œæˆå¾Œ
              if (completedParses === files.length) {
                processParsedFiles(parsedFiles);
              }
            },
            error: function (error) {
              console.error("Parsing error:", file.name, error);
              completedParses++;
              if (completedParses === files.length) {
                processParsedFiles(parsedFiles);
              }
            },
          });
        });
      }

      function processParsedFiles(fileList) {
        // 2. åˆ©ç”¨ CSV å…§çš„ã€ŒFileNameã€æ¬„ä½ä¾†åˆ¤æ–·èˆ‡æ’åº
        // æ ¼å¼: EFè¨“ç·´éŠæˆ²æ•¸æ“š_ID_YYYYMMDD_HHMMSS.csv
        const filenameRegex = /^EFè¨“ç·´éŠæˆ²æ•¸æ“š_(.+)_(\d{8})_(\d{6})\.csv$/;

        let validSessions = [];

        for (let f of fileList) {
          if (!f.data || f.data.length === 0) continue;

          // å„ªå…ˆä½¿ç”¨ CSV å…§éƒ¨çš„ FileName æ¬„ä½ï¼Œè‹¥ç„¡å‰‡ä½¿ç”¨ä¸Šå‚³çš„æª”å
          let internalFileName = f.data[0]["FileName"];
          if (!internalFileName) {
            internalFileName = f.uploadName;
          }

          const match = internalFileName.match(filenameRegex);
          if (!match) {
            showError(
              `æª”æ¡ˆ "${f.uploadName}" æ ¼å¼ä¸ç¬¦ (ç„¡æ³•å¾ FileName æ¬„ä½æˆ–æª”åè§£æ ID èˆ‡æ™‚é–“)ã€‚`
            );
            showLoading(false);
            return;
          }

          const participantId = match[1];
          const timestampStr = match[2] + match[3]; // YYYYMMDDHHMMSS

          validSessions.push({
            data: f.data,
            timestamp: timestampStr,
            fileName: internalFileName, // [æ–°å¢] å„²å­˜æª”åä»¥ä¾¿å¾ŒçºŒæ³¨å…¥
          });
        }

        if (validSessions.length === 0) {
          showError("æ²’æœ‰æœ‰æ•ˆçš„è³‡æ–™ã€‚");
          showLoading(false);
          return;
        }

        // 3. ä¾ç…§æ™‚é–“æ’åº
        validSessions.sort((a, b) => a.timestamp.localeCompare(b.timestamp));

        // 4. åˆä½µè³‡æ–™
        // [ä¿®æ”¹] åœ¨åˆä½µå‰ï¼Œç¢ºä¿æ¯ä¸€åˆ—è³‡æ–™éƒ½æœ‰ FileName æ¬„ä½
        const aggregatedData = validSessions.flatMap((s) => {
          s.data.forEach((row) => (row.FileName = s.fileName));
          return s.data;
        });
        processAggregatedData(aggregatedData);
      }

      function processAggregatedData(data) {
        parsedData = data;
        console.log("è§£æå®Œæˆï¼Œå…±", parsedData.length, "ç­†è³‡æ–™");

        if (parsedData.length === 0) {
          showError("ç„¡æ³•è§£æè³‡æ–™æˆ–è³‡æ–™ç‚ºç©º");
          showLoading(false);
          return;
        }

        // åˆ†é¡è³‡æ–™
        regularTrials = parsedData.filter(
          (row) => row.Round && !row.Round.startsWith("WM")
        );
        wmTrials = parsedData.filter(
          (row) => row.Round && row.Round.startsWith("WM")
        );

        console.log("ä¸€èˆ¬è©¦é¡Œï¼š", regularTrials.length, "ç­†");
        console.log("å·¥ä½œè¨˜æ†¶æ¸¬è©¦ï¼š", wmTrials.length, "ç­†");

        showLoading(false);
        showPreview();
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // é¡¯ç¤ºé è¦½
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      function showPreview() {
        // é¡¯ç¤ºåƒèˆ‡è€…å§“å (æ”¯æ´å¤šäºº)
        const uniqueParticipants = [
          ...new Set(parsedData.map((d) => d.Participant).filter((p) => p)),
        ];
        let pNameDisplay = "æœªçŸ¥";

        if (uniqueParticipants.length === 1) {
          pNameDisplay = uniqueParticipants[0];
        } else if (uniqueParticipants.length > 1) {
          pNameDisplay = `${
            uniqueParticipants.length
          } ä½åƒèˆ‡è€… (${uniqueParticipants.slice(0, 2).join(", ")}...)`;
        }

        document.getElementById("participantName").textContent = pNameDisplay;

        // è¨ˆç®—çµ±è¨ˆï¼ˆåƒ…ä¸€èˆ¬è©¦é¡Œï¼‰
        const stats = calculateBasicStats(regularTrials);

        document.getElementById("totalTrials").textContent = stats.totalTrials;
        document.getElementById("correctRate").textContent =
          stats.correctRate.toFixed(1) + "%";
        document.getElementById("avgRT").textContent =
          Math.round(stats.avgRT) + " ms";
        document.getElementById("wmTests").textContent = wmTrials.length;

        document.getElementById("previewSection").style.display = "block";
        document
          .getElementById("previewSection")
          .scrollIntoView({ behavior: "smooth" });
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // è¨ˆç®—åŸºæœ¬çµ±è¨ˆ
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      function calculateBasicStats(data) {
        const totalTrials = data.length;

        // è¨ˆç®—æ­£ç¢ºç‡
        const correctTrials = data.filter(
          (row) =>
            row.Correct === "yes" ||
            row.Correct === "true" ||
            row.Correct === "1"
        ).length;
        const correctRate =
          totalTrials > 0 ? (correctTrials / totalTrials) * 100 : 0;

        // è¨ˆç®—å¹³å‡åæ‡‰æ™‚é–“ï¼ˆæ’é™¤ RT = 0 çš„è³‡æ–™ï¼‰
        const rtData = data
          .map((row) => parseFloat(row["RT(ms)"]))
          .filter((rt) => !isNaN(rt) && rt > 0);

        const avgRT =
          rtData.length > 0
            ? rtData.reduce((sum, rt) => sum + rt, 0) / rtData.length
            : 0;

        return { totalTrials, correctRate, avgRT };
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ç”Ÿæˆæ‰€æœ‰åœ–è¡¨
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      function generateCharts() {
        document.getElementById("chartsSection").style.display = "block";

        generateStatsCards();

        // ç”Ÿæˆå„å›åˆåœ–è¡¨
        generateRoundChart(1, "round1RTChart");
        generateRoundChart(2, "round2RTChart");
        generateRoundChart(3, "round3RTChart");
        generateRoundChart(4, "round4RTChart");

        // ç”Ÿæˆç¶œåˆæ¯”è¼ƒåœ–è¡¨
        generateAccuracyComparisonChart();
        generateRTComparisonChart();

        // é¡¯ç¤ºå·¥ä½œè¨˜æ†¶æ¸¬è©¦çµæœ
        displayWMResults();

        // ç”Ÿæˆå·¥ä½œè¨˜æ†¶åœ–è¡¨
        generateWMCharts();

        document
          .getElementById("chartsSection")
          .scrollIntoView({ behavior: "smooth" });
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // çµ±è¨ˆå¡ç‰‡
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      function generateStatsCards() {
        const statsGrid = document.getElementById("statsGrid");

        // è¨ˆç®—å„å›åˆçµ±è¨ˆ
        const rounds = [1, 2, 3, 4];
        let cardsHTML = "";

        rounds.forEach((roundNum) => {
          const roundData = regularTrials.filter(
            (row) => parseInt(row.Round) === roundNum
          );

          if (roundData.length === 0) return;

          const correct = roundData.filter(
            (row) => row.Correct === "yes"
          ).length;
          const accuracy = ((correct / roundData.length) * 100).toFixed(1);

          const rtData = roundData
            .map((row) => parseFloat(row["RT(ms)"]))
            .filter((rt) => !isNaN(rt) && rt > 0);
          const avgRT =
            rtData.length > 0
              ? Math.round(
                  rtData.reduce((sum, rt) => sum + rt, 0) / rtData.length
                )
              : 0;

          cardsHTML += `
                    <div class="stat-card">
                        <h3>å›åˆ ${roundNum} æ­£ç¢ºç‡</h3>
                        <div class="value">${accuracy}%</div>
                    </div>
                `;
        });

        statsGrid.innerHTML = cardsHTML;
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // å„å›åˆåœ–è¡¨
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      // [æ–°å¢] å®šç¾©ä¸€çµ„é¡è‰²ç”¨æ–¼å€åˆ†ä¸åŒå ´æ¬¡
      const sessionColors = [
        "#667eea", // è—ç´«
        "#ff9800", // æ©˜
        "#e91e63", // ç²‰ç´…
        "#00bcd4", // é’
        "#9c27b0", // ç´«
        "#3f51b5", // æ·±è—
        "#4caf50", // ç¶ 
      ];

      function generateRoundChart(roundNum, canvasId) {
        const ctx = document.getElementById(canvasId).getContext("2d");

        // éæ¿¾å‡ºè©²å›åˆçš„è³‡æ–™
        const roundData = regularTrials.filter(
          (row) => parseInt(row.Round) === roundNum
        );

        if (roundData.length === 0) {
          console.warn(`å›åˆ ${roundNum} æ²’æœ‰è³‡æ–™`);
          return;
        }

        // 1. æº–å‚™ X è»¸æ¨™ç±¤ (æ—¥æœŸèˆ‡æ™‚é–“åˆ†è¡Œ)
        const labels = roundData.map((row, index) => {
          const ts = row.Timestamp || "";
          const parts = ts.split(" "); // å‡è¨­æ ¼å¼ç‚º "YYYY/MM/DD HH:mm:ss"
          return [
            `ç¬¬ ${index + 1} é¡Œ`,
            row.Participant,
            parts[0] || ts, // æ—¥æœŸ
            parts[1] || "", // æ™‚é–“ (åˆ†è¡Œé¡¯ç¤º)
          ];
        });

        // 2. æ ¹æ“š FileName åˆ†çµ„è³‡æ–™ (å»ºç«‹å¤šå€‹ Dataset)
        const uniqueFiles = [...new Set(roundData.map((r) => r.FileName))];
        const datasets = uniqueFiles.map((fileName, fileIndex) => {
          // åˆå§‹åŒ–è©²å ´æ¬¡çš„è³‡æ–™é™£åˆ— (é•·åº¦éœ€èˆ‡ç¸½ labels ä¸€è‡´ï¼Œéè©²å ´æ¬¡å¡« null)
          const data = new Array(roundData.length).fill(null);
          const pointColors = new Array(roundData.length).fill(null);

          roundData.forEach((row, rowIndex) => {
            if (row.FileName === fileName) {
              const rt = parseFloat(row["RT(ms)"]);
              data[rowIndex] = !isNaN(rt) ? rt : 0;
              // [ä¿®æ”¹] é»çš„é¡è‰²ï¼šçµ±ä¸€ä½¿ç”¨è©²å›åˆçš„ä»£è¡¨è‰²
              pointColors[rowIndex] = ROUND_COLORS[roundNum];
            }
          });

          const color = sessionColors[fileIndex % sessionColors.length];

          return {
            label: fileName, // åœ–ä¾‹é¡¯ç¤ºæª”å
            data: data,
            borderColor: color, // ç·šæ¢é¡è‰²ä»£è¡¨å ´æ¬¡
            backgroundColor: color,
            pointBackgroundColor: pointColors, // é»é¡è‰²ä»£è¡¨å°éŒ¯
            pointBorderColor: "#fff",
            pointRadius: 6,
            borderWidth: 2,
            tension: 0.3,
            spanGaps: false, // ä¸é€£æ¥ä¸åŒå ´æ¬¡çš„ç·š
          };
        });

        // [æ–°å¢] åŠ å…¥ä¸€å€‹ Dummy Dataset è®“ã€Œé»ã€çš„èªªæ˜å‡ºç¾åœ¨ä¸Šæ–¹åœ–ä¾‹ä¸­
        datasets.push({
          label: `Round ${roundNum} è©¦é¡Œ`,
          data: [], // ä¸é¡¯ç¤ºæ•¸æ“šï¼Œåªé¡¯ç¤ºåœ–ä¾‹
          borderColor: ROUND_COLORS[roundNum],
          backgroundColor: ROUND_COLORS[roundNum],
          pointBackgroundColor: ROUND_COLORS[roundNum],
          pointBorderColor: "#fff",
          pointRadius: 6,
          borderWidth: 0, // ä¸é¡¯ç¤ºç·šæ¢
        });

        // éŠ·æ¯€èˆŠåœ–è¡¨
        if (charts[canvasId]) charts[canvasId].destroy();

        // å»ºç«‹åœ–è¡¨
        charts[canvasId] = new Chart(ctx, {
          type: "line",
          data: {
            labels: labels,
            datasets: datasets,
          },
          options: {
            responsive: true,
            maintainAspectRatio: true,
            plugins: {
              legend: {
                display: true,
                labels: {
                  usePointStyle: true, // å•Ÿç”¨è‡ªè¨‚é»æ¨£å¼
                  generateLabels: function (chart) {
                    // å–å¾—é è¨­ç”Ÿæˆçš„æ¨™ç±¤
                    const original =
                      Chart.defaults.plugins.legend.labels.generateLabels(
                        chart
                      );
                    // ä¿®æ”¹æ¨£å¼
                    original.forEach((label) => {
                      const dataset = chart.data.datasets[label.datasetIndex];
                      if (label.text.includes("Round")) {
                        label.pointStyle = "circle"; // å›åˆèªªæ˜é¡¯ç¤ºç‚ºåœ“å½¢
                      } else {
                        label.pointStyle = "rectRounded"; // æª”åé¡¯ç¤ºç‚ºåœ“è§’çŸ©å½¢ (è¼ƒå¤§)
                        if (dataset) {
                          label.fillStyle = dataset.borderColor; // [ä¿®æ­£] å¼·åˆ¶ä½¿ç”¨ç·šæ¢é¡è‰²
                          label.strokeStyle = dataset.borderColor;
                        }
                      }
                    });
                    return original;
                  },
                },
              },
              tooltip: {
                callbacks: {
                  afterLabel: function (context) {
                    const index = context.dataIndex;
                    const row = roundData[index];
                    const isCorrect = row.Correct === "yes";
                    const stimulus = row.Stimulus;
                    const hasPerson = row.HasPerson === "true";
                    const isNight = row.IsNightTime === "true";

                    let info = isCorrect ? "âœ… æ­£ç¢º" : "âŒ éŒ¯èª¤";
                    info += `\nåˆºæ¿€ç‰©ï¼š${stimulus}`;
                    if (hasPerson) info += "\nğŸ‘¤ æœ‰äººå‡ºç¾";
                    if (isNight) info += "\nğŸŒ™ æ™šä¸Š";
                    info += `\næŒ‰éµï¼š${row.InputKey}`;

                    return info;
                  },
                },
              },
            },
            scales: {
              y: {
                beginAtZero: true,
                title: {
                  display: true,
                  text: "åæ‡‰æ™‚é–“ (æ¯«ç§’)",
                  font: {
                    size: 14,
                    weight: "bold",
                  },
                },
              },
              x: {
                title: {
                  display: true,
                  text: "è©¦é¡Œç·¨è™Ÿ",
                  font: {
                    size: 14,
                    weight: "bold",
                  },
                },
              },
            },
          },
        });
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // æ­£ç¢ºç‡æ¯”è¼ƒåœ–
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      function generateAccuracyComparisonChart() {
        const ctx = document
          .getElementById("accuracyComparisonChart")
          .getContext("2d");

        const rounds = [1, 2, 3, 4];
        const accuracies = rounds.map((roundNum) => {
          const roundData = regularTrials.filter(
            (row) => parseInt(row.Round) === roundNum
          );
          if (roundData.length === 0) return 0;
          const correct = roundData.filter(
            (row) => row.Correct === "yes"
          ).length;
          return (correct / roundData.length) * 100;
        });

        if (charts.accuracyComparison) charts.accuracyComparison.destroy();

        charts.accuracyComparison = new Chart(ctx, {
          type: "bar",
          data: {
            labels: ["å›åˆ 1", "å›åˆ 2", "å›åˆ 3", "å›åˆ 4"],
            datasets: [
              {
                label: "æ­£ç¢ºç‡ (%)",
                data: accuracies,
                backgroundColor: [
                  ROUND_COLORS[1],
                  ROUND_COLORS[2],
                  ROUND_COLORS[3],
                  ROUND_COLORS[4],
                ],
                borderColor: [
                  ROUND_COLORS[1].replace("0.8", "1"),
                  ROUND_COLORS[2].replace("0.8", "1"),
                  ROUND_COLORS[3].replace("0.8", "1"),
                  ROUND_COLORS[4].replace("0.8", "1"),
                ],
                borderWidth: 2,
              },
            ],
          },
          options: {
            responsive: true,
            scales: {
              y: {
                beginAtZero: true,
                max: 100,
                title: {
                  display: true,
                  text: "æ­£ç¢ºç‡ (%)",
                  font: { size: 14, weight: "bold" },
                },
              },
            },
            plugins: {
              legend: { display: false },
            },
          },
        });
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // åæ‡‰æ™‚é–“æ¯”è¼ƒåœ–
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      function generateRTComparisonChart() {
        const ctx = document
          .getElementById("rtComparisonChart")
          .getContext("2d");

        const rounds = [1, 2, 3, 4];
        const avgRTs = rounds.map((roundNum) => {
          const roundData = regularTrials.filter(
            (row) => parseInt(row.Round) === roundNum
          );
          const rtData = roundData
            .map((row) => parseFloat(row["RT(ms)"]))
            .filter((rt) => !isNaN(rt) && rt > 0);
          return rtData.length > 0
            ? rtData.reduce((sum, rt) => sum + rt, 0) / rtData.length
            : 0;
        });

        if (charts.rtComparison) charts.rtComparison.destroy();

        charts.rtComparison = new Chart(ctx, {
          type: "line",
          data: {
            labels: ["å›åˆ 1", "å›åˆ 2", "å›åˆ 3", "å›åˆ 4"],
            datasets: [
              {
                label: "å¹³å‡åæ‡‰æ™‚é–“ (ms)",
                data: avgRTs,
                borderColor: "#667eea",
                backgroundColor: "rgba(102, 126, 234, 0.1)",
                borderWidth: 3,
                tension: 0.4,
                fill: true,
                pointRadius: 10,
                pointBackgroundColor: [
                  ROUND_COLORS[1],
                  ROUND_COLORS[2],
                  ROUND_COLORS[3],
                  ROUND_COLORS[4],
                ],
                pointBorderColor: "#fff",
                pointBorderWidth: 3,
              },
            ],
          },
          options: {
            responsive: true,
            scales: {
              y: {
                beginAtZero: true,
                title: {
                  display: true,
                  text: "å¹³å‡åæ‡‰æ™‚é–“ (æ¯«ç§’)",
                  font: { size: 14, weight: "bold" },
                },
              },
            },
          },
        });
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // é¡¯ç¤ºå·¥ä½œè¨˜æ†¶æ¸¬è©¦çµæœ
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      function displayWMResults() {
        const wmResultsDiv = document.getElementById("wmResults");

        if (wmTrials.length === 0) {
          wmResultsDiv.innerHTML = "<p>æ²’æœ‰å·¥ä½œè¨˜æ†¶æ¸¬è©¦è³‡æ–™</p>";
          return;
        }

        // [æ–°å¢] å–å¾—æ‰€æœ‰æª”æ¡ˆåˆ—è¡¨ä»¥å°æ‡‰é¡è‰²
        const uniqueFiles = [...new Set(parsedData.map((r) => r.FileName))];

        let html = "";
        wmTrials.forEach((row) => {
          const roundName = row.Round; // WM1, WM2, WM3, WM4
          const stimulus = row.Stimulus;
          const userAnswer = row.InputKey;
          const rt = parseFloat(row["RT(ms)"]);
          const participant = row.Participant;
          const timestamp = row.Timestamp;

          // [æ–°å¢] æ±ºå®šè©²ç­†è³‡æ–™çš„é¡è‰² (ä¾æ“šæª”æ¡ˆ)
          const fileIndex = uniqueFiles.indexOf(row.FileName);
          const fileColor = sessionColors[fileIndex % sessionColors.length];

          // [æ–°å¢] è¨ˆç®—ä½ç½®æ­£ç¢ºç‡
          const correctAnswer = stimulus.split("-");
          const userAnswerArray = userAnswer.split("-");
          let correctCount = 0;
          let comparisonHTML =
            '<div style="display: flex; gap: 10px; margin: 10px 0;">';

          for (let i = 0; i < correctAnswer.length; i++) {
            const isCorrect = correctAnswer[i] === userAnswerArray[i];
            if (isCorrect) correctCount++;

            // ä½ç½®æ¨™è¨˜
            const bgColor = isCorrect ? "#c8e6c9" : "#ffcdd2";
            const icon = isCorrect ? "âœ“" : "âœ—";

            comparisonHTML += `
                        <div style="flex: 1; background: ${bgColor}; padding: 10px; border-radius: 5px; text-align: center;">
                            <div style="font-size: 1.2em; font-weight: bold; color: #333;">
                                ä½ç½® ${i + 1} ${icon}
                            </div>
                            <div style="font-size: 0.9em; color: #666; margin-top: 5px;">
                                æ­£ç¢ºï¼š${correctAnswer[i]}<br>
                                å›ç­”ï¼š${userAnswerArray[i]}
                            </div>
                        </div>
                    `;
          }
          comparisonHTML += "</div>";

          const accuracy = (
            (correctCount / correctAnswer.length) *
            100
          ).toFixed(1);
          const isFullyCorrect = correctCount === correctAnswer.length;

          html += `
                    <div style="background: white; padding: 20px; border-radius: 10px; margin-bottom: 15px; border-left: 8px solid ${fileColor}; box-shadow: 0 2px 5px rgba(0,0,0,0.1);">
                        <div style="display: flex; justify-content: space-between; align-items: flex-start; margin-bottom: 10px;">
                            <div>
                                <h4 style="color: #333; margin: 0;">
                                    ${
                                      roundName === "WM1"
                                        ? "ğŸ§  å·¥ä½œè¨˜æ†¶æ¸¬è©¦ 1"
                                        : roundName === "WM2"
                                        ? "ğŸ§  å·¥ä½œè¨˜æ†¶æ¸¬è©¦ 2"
                                        : roundName === "WM3"
                                        ? "ğŸ§  å·¥ä½œè¨˜æ†¶æ¸¬è©¦ 3"
                                        : "ğŸ§  å·¥ä½œè¨˜æ†¶æ¸¬è©¦ 4"
                                    }
                                    <span style="color: ${
                                      isFullyCorrect ? "#4CAF50" : "#ff9800"
                                    }; margin-left: 10px;">
                                        ${accuracy}% (${correctCount}/${
            correctAnswer.length
          })
                                    </span>
                                </h4>
                                <div style="font-size: 0.9em; color: #666; margin-top: 5px;">
                                    ğŸ‘¤ åƒèˆ‡è€…ï¼š${participant} | ğŸ“… æ™‚é–“ï¼š${timestamp}
                                </div>
                            </div>
                            <div style="font-size: 0.8em; color: ${fileColor}; border: 1px solid ${fileColor}; padding: 2px 8px; border-radius: 12px;">
                                ${row.FileName}
                            </div>
                        </div>
                        
                        ${comparisonHTML}
                        
                        <div style="margin-top: 15px; padding: 10px; background: #f5f5f5; border-radius: 5px;">
                            <p style="color: #666; margin: 5px 0;">
                                <strong>ğŸ¯ æ­£ç¢ºç‡ï¼š</strong> ${accuracy}% 
                                ${
                                  isFullyCorrect
                                    ? "ğŸ‰ å®Œå…¨æ­£ç¢ºï¼"
                                    : accuracy >= 60
                                    ? "ğŸ‘ éƒ¨åˆ†æ­£ç¢º"
                                    : "âŒ éœ€è¦åŠ å¼·"
                                }
                            </p>
                            <p style="color: #666; margin: 5px 0;">
                                <strong>â±ï¸ åæ‡‰æ™‚é–“ï¼š</strong> ${Math.round(
                                  rt
                                )} æ¯«ç§’ (ç´„ ${(rt / 1000).toFixed(1)} ç§’)
                            </p>
                        </div>
                    </div>
                `;
        });

        wmResultsDiv.innerHTML = html;
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // ç”Ÿæˆå·¥ä½œè¨˜æ†¶æ¸¬è©¦åœ–è¡¨
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      function generateWMCharts() {
        if (wmTrials.length === 0) {
          console.warn("æ²’æœ‰å·¥ä½œè¨˜æ†¶æ¸¬è©¦è³‡æ–™");
          return;
        }

        // 1. æº–å‚™ X è»¸æ¨™ç±¤ (æ—¥æœŸèˆ‡æ™‚é–“åˆ†è¡Œ)
        const wmLabels = wmTrials.map((row) => {
          const roundNum = row.Round.replace("WM", "");
          const ts = row.Timestamp || "";
          const parts = ts.split(" ");
          return [
            `WM${roundNum}`,
            row.Participant,
            parts[0] || ts,
            parts[1] || "",
          ];
        });

        // [ä¿®æ”¹] è¨ˆç®—ä½ç½®æ­£ç¢ºç‡ï¼ˆè€Œéæ•´é¡Œå°éŒ¯ï¼‰
        const wmAccuracies = wmTrials.map((row) => {
          const correctAnswer = row.Stimulus.split("-");
          const userAnswer = row.InputKey.split("-");

          // å¦‚æœé•·åº¦ä¸åŒï¼Œè¿”å› 0
          if (correctAnswer.length !== userAnswer.length) {
            return 0;
          }

          // è¨ˆç®—æœ‰å¤šå°‘ä½ç½®æ˜¯æ­£ç¢ºçš„
          let correctPositions = 0;
          for (let i = 0; i < correctAnswer.length; i++) {
            if (correctAnswer[i] === userAnswer[i]) {
              correctPositions++;
            }
          }

          // è¨ˆç®—æ­£ç¢ºç‡ï¼ˆç™¾åˆ†æ¯”ï¼‰
          const accuracy = (correctPositions / correctAnswer.length) * 100;
          return accuracy;
        });

        // [ä¿®æ”¹] é¡è‰²æ ¹æ“šæ­£ç¢ºç‡è¨­å®šï¼ˆæ¼¸å±¤ï¼‰
        const wmColors = wmAccuracies.map((accuracy) => {
          if (accuracy === 100) {
            // 100% = æ·±ç¶ è‰²
            return "rgba(76, 175, 80, 0.9)";
          } else if (accuracy >= 80) {
            // 80-99% = æ·ºç¶ è‰²
            return "rgba(139, 195, 74, 0.8)";
          } else if (accuracy >= 60) {
            // 60-79% = é»ƒç¶ è‰²
            return "rgba(205, 220, 57, 0.8)";
          } else if (accuracy >= 40) {
            // 40-59% = æ©˜è‰²
            return "rgba(255, 152, 0, 0.8)";
          } else if (accuracy > 0) {
            // 1-39% = æ·ºç´…è‰²
            return "rgba(239, 83, 80, 0.8)";
          } else {
            // 0% = æ·±ç´…è‰²
            return "rgba(244, 67, 54, 0.9)";
          }
        });

        // åœ–è¡¨ 1ï¼šå·¥ä½œè¨˜æ†¶æ­£ç¢ºç‡
        const ctxAccuracy = document
          .getElementById("wmAccuracyChart")
          .getContext("2d");

        if (charts.wmAccuracy) charts.wmAccuracy.destroy();

        // æº–å‚™ Accuracy Datasets (ä¾å ´æ¬¡åˆ†çµ„)
        // [ä¿®æ”¹] ä½¿ç”¨å…¨åŸŸå®šç¾©çš„ ROUND_COLORS
        const wmRoundColors = {
          WM1: ROUND_COLORS[1],
          WM2: ROUND_COLORS[2],
          WM3: ROUND_COLORS[3],
          WM4: ROUND_COLORS[4],
        };

        const uniqueFiles = [...new Set(wmTrials.map((r) => r.FileName))];
        const accDatasets = uniqueFiles.map((fileName, fileIndex) => {
          const data = new Array(wmTrials.length).fill(null);
          const pointColors = new Array(wmTrials.length).fill(null);

          wmTrials.forEach((row, rowIndex) => {
            if (row.FileName === fileName) {
              data[rowIndex] = wmAccuracies[rowIndex];
              // [ä¿®æ”¹] æ ¹æ“š WM å›åˆè¨­å®šé¡è‰²ï¼Œè€Œéå ´æ¬¡
              const c = wmRoundColors[row.Round] || "rgba(201, 203, 207, 0.8)";
              pointColors[rowIndex] = c;
            }
          });

          const color = sessionColors[fileIndex % sessionColors.length];

          return {
            label: fileName,
            data: data,
            borderColor: color,
            backgroundColor: color,
            pointBackgroundColor: pointColors,
            pointBorderColor: "#fff",
            pointRadius: 6,
            borderWidth: 2,
            tension: 0.3,
            spanGaps: false,
          };
        });

        // [æ–°å¢] åŠ å…¥ Dummy Datasets è®“ WM å›åˆèªªæ˜å‡ºç¾åœ¨ä¸Šæ–¹åœ–ä¾‹ä¸­
        for (const [round, color] of Object.entries(wmRoundColors)) {
          accDatasets.push({
            label: round,
            data: [],
            borderColor: color,
            backgroundColor: color,
            pointBackgroundColor: color,
            pointBorderColor: "#fff",
            pointRadius: 6,
            borderWidth: 0,
          });
        }

        charts.wmAccuracy = new Chart(ctxAccuracy, {
          type: "line", // [ä¿®æ”¹] æ”¹ç‚ºæŠ˜ç·šåœ–ï¼Œèˆ‡åæ‡‰æ™‚é–“åœ–è¡¨ä¸€è‡´
          data: {
            labels: wmLabels,
            datasets: accDatasets,
          },
          options: {
            responsive: true,
            scales: {
              y: {
                beginAtZero: true,
                max: 100,
                title: {
                  display: true,
                  text: "æ­£ç¢ºç‡ (%)",
                  font: { size: 14, weight: "bold" },
                },
                ticks: {
                  stepSize: 20,
                },
              },
              x: {
                title: {
                  display: true,
                  text: "å·¥ä½œè¨˜æ†¶æ¸¬è©¦",
                  font: { size: 14, weight: "bold" },
                },
              },
            },
            plugins: {
              legend: {
                display: true,
                labels: {
                  usePointStyle: true,
                  generateLabels: function (chart) {
                    const original =
                      Chart.defaults.plugins.legend.labels.generateLabels(
                        chart
                      );
                    original.forEach((label) => {
                      const dataset = chart.data.datasets[label.datasetIndex];
                      if (["WM1", "WM2", "WM3", "WM4"].includes(label.text)) {
                        label.pointStyle = "circle";
                      } else {
                        label.pointStyle = "rectRounded";
                        if (dataset) {
                          label.fillStyle = dataset.borderColor;
                          label.strokeStyle = dataset.borderColor;
                        }
                      }
                    });
                    return original;
                  },
                },
              },
              tooltip: {
                callbacks: {
                  label: function (context) {
                    const index = context.dataIndex;
                    const row = wmTrials[index];
                    const accuracy = wmAccuracies[index];

                    // è¨ˆç®—æ­£ç¢º/éŒ¯èª¤ä½ç½®æ•¸
                    const correctAnswer = row.Stimulus.split("-");
                    const userAnswer = row.InputKey.split("-");
                    let correctCount = 0;
                    for (let i = 0; i < correctAnswer.length; i++) {
                      if (correctAnswer[i] === userAnswer[i]) {
                        correctCount++;
                      }
                    }
                    const totalCount = correctAnswer.length;

                    return [
                      `æ­£ç¢ºç‡ï¼š${accuracy.toFixed(1)}%`,
                      `æ­£ç¢ºä½ç½®ï¼š${correctCount} / ${totalCount}`,
                      accuracy === 100
                        ? "ğŸ‰ å®Œå…¨æ­£ç¢ºï¼"
                        : accuracy >= 60
                        ? "ğŸ‘ éƒ¨åˆ†æ­£ç¢º"
                        : "âŒ éœ€è¦åŠ å¼·",
                    ];
                  },
                },
              },
            },
          },
        });

        // åœ–è¡¨ 2ï¼šå·¥ä½œè¨˜æ†¶åæ‡‰æ™‚é–“
        const ctxRT = document.getElementById("wmRTChart").getContext("2d");

        if (charts.wmRT) charts.wmRT.destroy();

        // æº–å‚™ RT Datasets (ä¾å ´æ¬¡åˆ†çµ„)
        // [ä¿®æ­£] ç§»é™¤é‡è¤‡å®£å‘Šçš„ uniqueFilesï¼Œç›´æ¥ä½¿ç”¨ä¸Šé¢å·²å®šç¾©çš„è®Šæ•¸
        const rtDatasets = uniqueFiles.map((fileName, fileIndex) => {
          const data = new Array(wmTrials.length).fill(null);
          const pointColors = new Array(wmTrials.length).fill(null);

          wmTrials.forEach((row, rowIndex) => {
            if (row.FileName === fileName) {
              const rt = parseFloat(row["RT(ms)"]);
              data[rowIndex] = !isNaN(rt) ? rt : 0;
              // [ä¿®æ”¹] ä½¿ç”¨ WM å›åˆé¡è‰²
              const c = wmRoundColors[row.Round] || "rgba(201, 203, 207, 0.8)";
              pointColors[rowIndex] = c;
            }
          });

          const color = sessionColors[fileIndex % sessionColors.length];

          return {
            label: fileName,
            data: data,
            borderColor: color,
            backgroundColor: color,
            pointBackgroundColor: pointColors,
            pointBorderColor: "#fff",
            pointRadius: 6,
            borderWidth: 2,
            tension: 0.3,
            spanGaps: false,
          };
        });

        // [æ–°å¢] åŠ å…¥ Dummy Datasets è®“ WM å›åˆèªªæ˜å‡ºç¾åœ¨ä¸Šæ–¹åœ–ä¾‹ä¸­
        for (const [round, color] of Object.entries(wmRoundColors)) {
          rtDatasets.push({
            label: round,
            data: [],
            borderColor: color,
            backgroundColor: color,
            pointBackgroundColor: color,
            pointBorderColor: "#fff",
            pointRadius: 6,
            borderWidth: 0,
          });
        }

        charts.wmRT = new Chart(ctxRT, {
          type: "line",
          data: {
            labels: wmLabels,
            datasets: rtDatasets,
          },
          options: {
            responsive: true,
            scales: {
              y: {
                beginAtZero: true,
                title: {
                  display: true,
                  text: "åæ‡‰æ™‚é–“ (æ¯«ç§’)",
                  font: { size: 14, weight: "bold" },
                },
              },
              x: {
                title: {
                  display: true,
                  text: "å·¥ä½œè¨˜æ†¶æ¸¬è©¦",
                  font: { size: 14, weight: "bold" },
                },
              },
            },
            plugins: {
              legend: {
                display: true,
                labels: {
                  usePointStyle: true,
                  generateLabels: function (chart) {
                    const original =
                      Chart.defaults.plugins.legend.labels.generateLabels(
                        chart
                      );
                    original.forEach((label) => {
                      const dataset = chart.data.datasets[label.datasetIndex];
                      if (["WM1", "WM2", "WM3", "WM4"].includes(label.text)) {
                        label.pointStyle = "circle";
                      } else {
                        label.pointStyle = "rectRounded";
                        if (dataset) {
                          label.fillStyle = dataset.borderColor;
                          label.strokeStyle = dataset.borderColor;
                        }
                      }
                    });
                    return original;
                  },
                },
              },
              tooltip: {
                callbacks: {
                  afterLabel: function (context) {
                    const index = context.dataIndex;
                    const row = wmTrials[index];
                    const accuracy = wmAccuracies[index];
                    const rt = Math.round(parseFloat(row["RT(ms)"]));

                    // è¨ˆç®—æ­£ç¢º/éŒ¯èª¤ä½ç½®æ•¸
                    const correctAnswer = row.Stimulus.split("-");
                    const userAnswer = row.InputKey.split("-");
                    let correctCount = 0;
                    for (let i = 0; i < correctAnswer.length; i++) {
                      if (correctAnswer[i] === userAnswer[i]) {
                        correctCount++;
                      }
                    }
                    const totalCount = correctAnswer.length;

                    let info = `æ­£ç¢ºç‡ï¼š${accuracy.toFixed(1)}%`;
                    info += `\næ­£ç¢ºä½ç½®ï¼š${correctCount} / ${totalCount}`;
                    info += `\nåæ‡‰æ™‚é–“ï¼š${rt} æ¯«ç§’`;
                    info += `\nç´„ ${(rt / 1000).toFixed(1)} ç§’`;

                    return info;
                  },
                },
              },
            },
          },
        });
      }

      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•
      // è¼”åŠ©å‡½æ•¸
      // â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•â•

      function showLoading(show) {
        document.getElementById("loading").style.display = show
          ? "block"
          : "none";
      }

      function showError(message) {
        const errorDiv = document.getElementById("errorMessage");
        errorDiv.textContent = "âŒ " + message;
        errorDiv.style.display = "block";
      }

      function hideError() {
        document.getElementById("errorMessage").style.display = "none";
      }

      function resetApp() {
        parsedData = null;
        regularTrials = [];
        wmTrials = [];
        document.getElementById("csvFile").value = "";
        document.getElementById("previewSection").style.display = "none";
        document.getElementById("chartsSection").style.display = "none";
        hideError();
        window.scrollTo({ top: 0, behavior: "smooth" });
      }
    </script>
  </body>
</html>
